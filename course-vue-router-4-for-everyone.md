# Vue Router 4 for Everyone

## Isntall `vue-router`

Use the following command:

```sh
npm install vue-router@4 --save
```

## Adding routes

It is done in the `main.js` file.

The routes can be imported from an external file outside of `main.js`.

A route is defined like this:

```javascript
  routes: [
    //routes go here
    {
        //the path is the url when you navigate in the browser
        path: '/',
        //the name of the route, which is a more handy way to use <router-link> component
        name: 'Home',
        //the component to load for the route
        component: HomeVue
    },

```

## Using `router-view` to render a page

To render the view for a route, you need to include
in the `App.vue` the component `router-view`.

```htm
<template>
  <RouterView></RouterView>
</template>
```

or

```htm
<template>
  <router-view></router-view>
</template>
```

## Using `router-link` to render routed links

If you want to build the navigation, for example, using the `router-link` component enables to create adequate links:

```htm
<template>
  <router-link to="/">Home</router-link> |
  <router-link to="/about">About</router-link>
  <router-view></router-view>
</template>
```

Using `router-link` instead of `a` elements makes possible to load just what we need instead of everything on each pageload.

If you open the DevTools, the `router-link` is rendered as `a` element.

But Vue router intercepts the click events so the browser doesn't reload the page.

Therefore, we'll use `a` elements for external links and `router-link` for internal links.

## Extracting routes to its own file

This is commun practice. You create a `router` under `src` where you add `inde.js` with the setup of the router.

```javascript
import { createRouter, createWebHistory } from 'vue-router';

import HomeVue from '../views/Home.vue';
import AboutVue from '../views/About.vue';

const routes = [
  //routes go here
  { path: '/', name: 'Home', component: HomeVue },
  { path: '/about', name: 'About', component: AboutVue },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

export default router;
```

## History Mode: HTML5 vs Hash

What is the difference?

The `#` mode is there to imitate a file path without the server setup. It is used in SPAs.

Without the `#`, it uses the HTML5 native web history feature.

The drawback of `#` mode has a bad impact on SEO, so prefer not using it for public applications.

So in Vue applications, use `createWebHistory`, which is the HTML5 mode.

## Lazy Loading routes

Without lazy loading, all the JavaScript modules of all routes will be loaded. It is not efficient.

To lazy load routes, you need to use code splitting of the bundles generated by the builder ; in my case, I use Vite.

Without lazy loading, you define a route this way:

```javascript
import BrazilVue from '@/views/Brazil.vue';
var routes = [
  {
    path: '/brazil',
    name: 'brazil',
    component: BrazilVue'),
  }
]
```

The result is in the `dist` folder, you have a JavaScript file (`index-[hash].js`).

With lazy loading, you define a route with a dynamic import:

```javascript
var routes = [
  {
    path: '/brazil',
    name: 'brazil',
    component: () => import('@/views/Brazil.vue'),
  }
]
```

The result is in the `dist` folder:

- the main JavaScript file (`index-[hash].js`)
- a JavaScript file for each component of each route.

With Vuecli, it uses a similar technique but using a Webpack comment to name the chunk with magic comment:

```javascript
var routes = [
  {
    path: '/brazil',
    name: 'brazil',
    component: () => import(/* webpackChunkName: "brazil" */ '@/views/Brazil.vue'),
  }
]
```

## Custimizing the router link active class

It is easy to do that with the `linkActiveClass` property in the `createRouter` options.

## Dynamic Routes

You can add parameters to a route using `:myparam`.
This parameter is accessible in the route object, under `params` object.

The `params` object contains properties whose names are the name of the parameters specified in the route's path.

As for the naming of the parameters, use `camelCase`, `PascalCase` or `snake_case`.

`kebab-case` will not work.

So:

- `myparam` will be available as `route.params.myparam`,
- `myParam` will be available as `route.params.myParam`,
- `my_param` will be available as `route.params.my_param`,
- `my-param` will **NOT** be available in `route.params`.

The best practice: I'd use [Douglas Crockford's](http://javascript.crockford.com/code.html) suggestions that say (in **bold what I think applies to naming route's params**):

> Names **should be formed from the 26 upper and lower case letters (A .. Z, a .. z), the 10 digits (0 .. 9)**, and \_ (underbar). **Avoid use of international characters because they may not read well or be understood everywhere. Do not use $ (dollar sign) or \ (backslash) in names**.
>
> **Do not use \_ (underbar) as the first character of a name**. It is sometimes used to indicate privacy, but it does not actually provide privacy. If privacy is important, use the forms that provide private members. Avoid conventions that demonstrate a lack of competence.
>
> Most variables and functions **should start with a lower case letter**.

Conclusion: I'll use `camelCase`.

Here for some discussion on the topic:

- [Stackoverflow](https://stackoverflow.com/a/21564097)
- [VueSchool.io (may require a subscription to access)](https://vueschool.io/lessons/dynamic-routes#comment-6364887960)

## Named routes

It is recommended to give all routes a name to use it in the code.

That will allow to change the path easily.

If you use `router-link` component with a route name that doesn't exist, you will get console warning:

```console
TheNavigation.vue:4 [Vue warn]: Property "doesntexist" was accessed during render but is not defined on instance.
  at <TheNavigation>
  at <App>
```

Interesting fact: if the route name equals `undefined` though, you will get no warning. But the `a` element will have `href` equal to the currently loaded page.

I wonder what is the best practice to use named routes within a component to avoid typos. I only found about the interesting fact because I tried to store the route names in an array to be reused in `src/router/index` and an application component.

## Reacting to Param Changes

We have two options:

1. use `watch` to listen on the `router.params` changes and fetch the new data.

2. ask Vue to recreate the component using the `key` attribut on the `router-view` component. The value is `$route.path`.

The second approach takes more JavaScript computation time.

But it is the solution to use most of the time you use the same component for different data.

## Usecase of Route Props

To build loosely-built component, passing props to routes make the code easier to maintain.

For example, a route would be defined at follows:

```javascript
const routes = [
      {
    path: '/destination-details/:id/:slug',
    name: routesNames.destinationShow,
    component: () => import('@/views/DestinationShow.vue'),
    props: (route) => ({ slug: route.params.slug }),
  },
]
```

It would be use the following way in the component:

```htm
<script setup>
    import useSourceData from "@/composables/useSourceData";

  const props = defineProps({
      slug:{
        type: String,
        required: true
      }
    })
    const { destination } = useSourceData(props.slug);
</script>
```

This way, the component can receive the props from any source: route, form input, etc...

## Nested routes

When you have an application with components nested multiple levels deep. In this case, it is very commun that a certain route segment corresponds to the matching component.

For example, a `DestinationDetails` component containing a list of `ExperienceDetails` component will be configured as follows:

- the destination route could be `/destination-details/:id/:slug`
- the experience route for a destination would be `:experienceSlug` and would be nested as a child route.

```javascript
const routes = [
  { path: '/', name: 'home', component: HomeVue },
  {
    //parent route
    path: '/destination-details/:id/:slug',
    name: routesNames.destinationShow,
    component: () => import('@/views/DestinationShow.vue'),
    props: (route) => ({ id: parseInt(route.params.id) }),
    children: [
      {
        //child route with only the extra segment needed.
        path: ':experienceSlug',
        name: 'experience-details',
        component: () => import('@/views/ExperienceShow.vue'),
        props: (route) => ({
          id: parseInt(route.params.id),
          experienceSlug: route.params.experienceSlug,
        }),
      },
    ],
  },
];

```

## Going back

The functionnality is available out-of-the-box with the instance of `$router`. It defines `back()` that acts exactly like the back button of a browser.

## Route transitions in SPA applications

The component `<transition>...</transition>` is available in Vue2 by wrapping the `<router-view>...</router-view>` component.

```htm
<transition>
  <router-view>...</router-view>
</transition>
```

In Vue3, the syntax was changed: `router-view` wraps the `transition` by using the router view slot. Then, the transition component contains an anonymous component that the component available in the slot.

```htm
<router-link v-slot="{ Component }">
  <transition name="slide">
    <component :is="Component" :key="$route.path"></component>
  </transition>
</router-link>
```

A key attribut equal to `$route.path` is mandatory on the anonymous component to insure the transition occurs properly and that the route changes continue to destroy and recreate the components to load.

**IMPORTANT**: for the transition component to apply the proper CSS classes on each page, **all pages must have a single root element**.

Otherwise, you will get a blank page and this warning in the console:

```console
[Vue warn]: Component inside <Transition> renders non-element root node that cannot be animated.
```

## What about routes that don't exist

You simply declare a route `catch all` using the Vue 3 syntax (more flexible and performant):

```javascript
const routes = [
  {
    path: '/:pathMatch(.*)*',
    name: 'notfound',
    component: NotFoundVue,
  },
]
```

In Vue 2, it was simplier to understand but gave us less flexibility:

```javascript
const routes = [
  {
    path: '*',
    name: 'notfound',
    component: NotFoundVue,
  },
]
```

## Navigation Guards

They allow to hook into the navigation process and perform checks and act accordingly: continue or show an error page.

For example, we define a route like the following:

```javascript
const routes = [
  //routes go here
  { path: '/', name: 'home', component: HomeVue },
  {
    path: '/destination-details/:id/:slug',
    name: routesNames.destinationShow,
    component: () => import('@/views/DestinationShow.vue'),
  },
];
```

The URL `/destination-details/1/france` could serve data, but maybe `/destination-details/100/france` won't. If the data doesn't exist, it won't be caught by the _catch all_ route.

That's when navigation guards are useful.

We define it on the appropriate event. In the example, **before** we **enter** the next route:

```javascript
    beforeEnter(to, from) {
      //to is the destination route
      //from is the origin route
      //so we want to check the data contains the element matching route.params.id
      const exists = sourceData.destinations.find(
        (element) => element.id === parseInt(to.params.id),
      );

      if (!exists) return { name: 'notfound' };

      //otherwise we continue
    },
```

If you want to keep the tURL intact even if it is wrong, you will need to add the following to return statement:

```javascript
        return {
          name: 'notfound',
          //allows keeping the URL intact while rendering a different page
          params: { pathMatch: to.path.split('/').slice(1) },
          query: to.query,
          hash: to.hash,
        };
```

## Handle scroll

You may notice that when you change route and if you scroll down, the scroll position is saved.

To use the _native behavior_ of non-SPA application, you will need to implement _scrollBehavior_ guard:

```javascript
const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior(to, from, savedPosition) {
    //this restore the top position with 300 ms dely to avoid a visual bug since we have a transition active.
    return (
      savedPosition ||
      new Promise((resolve) => {
        setTimeout(() => resolve({ top: 0, behavior: 'smooth' }), 300);
      })
    );
  },
});

```

## Route Meta fields

They are abitrary information passed along the route.

A common use case for route meta fields is to mark some routes as protected.

Using a application-wide guard, in the router definition, we can deal with the authentication requirement as follows:

```javascript
router.beforeEach((to, from) => {
  if (to.meta.requiresAuth && !window.user) {
    // Load a login page
    return {
      name: 'login',
    };
  }

  //Else continue
});
```

Using the push method on the router instance on the login page, for example, we can redirect the user to the protected area and log him out:

- for the login:

  ```javascript
  //script to handle the login (FAKE)
    import { ref } from 'vue';
    import { useRouter } from 'vue-router';

    const router = useRouter();

    const username = ref("");
    const password = ref("");

    const loginUser = () => {
      window.userLogged = `{user: ${username.value}, password: ${password.value}}`;
      router.push({name: 'protected'});
    }
  ```

- for the the logout:

  ```javascript
  //script of the protected area page
    import { useRouter } from 'vue-router';
    const router = useRouter();

  //data of user to display in the view
    const username = window.user;

    const logoutUser  = () => {
      window.user = undefined;
      router.push({name: 'home'});
    }

  ```

## Router Query Params

To read query parameters, it is as simple as reading the `query` object in the `route`.

An example usecase would be to include the path to a destination page after authentication.

For example, I have an invoices page that requires authentication. If I navigate to it directly, I'd want to return to the invoices page.

To do so, we need to modify the application guard:

```javascript
router.beforeEach((to, from) => {
  if (to.meta.requiresAuth && !window.userLogged) {
    // Load a login page
    return {
      name: 'login',
      //add the query string "redirect" with the requested path
      query: { redirect: to.fullPath },
    };
  }

  //else we continue
});
```

## Extending Router Link for External URLs

Again, to navigate to external links, we don't use `router-link` but a regular `a` element.

However, it is a good idea to use a single application-web component for both `router-link` and regular `a` element.

We would then create an `AppLink.vue` (to follow the style guidelines).

It would look like this:

```javascript
<template>
  <a
    v-if="isExternal"
    :href="to"
    target="_blank"
    rel="noopener"
    class="external-link"
    ><slot></slot
  ></a>
  <router-link v-else v-bind="$props" class="internal-link"
    ><slot></slot
  ></router-link>
</template>
<script setup>
  import { computed, guardReactiveProps } from 'vue';
  import { RouterLink } from 'vue-router';

  const props = defineProps({
      ...RouterLink.props
  });

  const isExternal = computed(() => {
    return typeof props.to === "string" && props.to.startsWith('http');
  });
</script>
```

And its usage would be:

```javascript
    <AppLink :to="{name: 'dashboard'}">Dashboard</AppLink>
    <AppLink to="https://google.com">Google</AppLink>
```
